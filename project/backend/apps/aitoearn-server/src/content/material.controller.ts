/*
 * @Author: nevin
 * @Date: 2024-06-17 19:19:20
 * @LastEditTime: 2024-12-23 12:45:22
 * @LastEditors: nevin
 * @Description: Material Controller
 */
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Post,
  Put,
  Query,
} from '@nestjs/common'
import { ApiTags } from '@nestjs/swagger'
import { GetToken, TokenInfo } from '@yikart/aitoearn-auth'
import { ApiDoc, AppException, ResponseCode, TableDto, UserType } from '@yikart/common'
import { MaterialStatus, MaterialType, MediaType } from '@yikart/mongodb'
import { fileUtil } from '../common/utils/file.util'
import {
  CreateMaterialDto,
  CreateMaterialTaskDto,
  MaterialFilterDto,
  MaterialFilterSchema,
  MaterialIdsDto,
  UpdateMaterialDto,
} from './dto/material.dto'
import { MaterialService } from './material.service'
import { MaterialGroupService } from './materialGroup.service'
import { MaterialTaskService } from './materialTask.service'
import { MediaGroupService } from './mediaGroup.service'

export const MediaMaterialTypeMap = new Map<MediaType, MaterialType>([
  [MediaType.VIDEO, MaterialType.VIDEO],
  [MediaType.IMG, MaterialType.ARTICLE],
])

@ApiTags('OpenSource/Me/Material')
@Controller('material')
export class MaterialController {
  constructor(
    private readonly materialService: MaterialService,
    private readonly materialGroupService: MaterialGroupService,
    private readonly materialTaskService: MaterialTaskService,
    private readonly mediaGroupService: MediaGroupService,
  ) { }

  @ApiDoc({
    summary: 'Create Draft',
    description: 'Create a draft with the provided media and metadata.',
    body: CreateMaterialDto.schema,
  })
  @Post()
  async create(
    @GetToken() token: TokenInfo,
    @Body() body: CreateMaterialDto,
  ) {
    const getInfo = await this.materialGroupService.getGroupInfo(body.groupId)
    if (!getInfo) {
      throw new AppException(ResponseCode.MaterialGroupNotFound)
    }

    const res = await this.materialService.create({
      ...body,
      userId: token.id,
      userType: UserType.User,
      type: getInfo?.type,
      status: MaterialStatus.SUCCESS,
    })
    return res
  }

  @ApiDoc({
    summary: 'Create Draft Generation Task',
    description: 'Create a batch task to generate drafts.',
    body: CreateMaterialTaskDto.schema,
  })
  @Post('task/create')
  async createTask(
    @GetToken() token: TokenInfo,
    @Body() body: CreateMaterialTaskDto,
  ) {
    // await this.userService.checkUserVipRights(token.id)
    const mediaGroupInfo = await this.mediaGroupService.getInfo(body.mediaGroups[0])
    if (!mediaGroupInfo) {
      throw new AppException(ResponseCode.MaterialGroupNotFound)
    }

    const type = mediaGroupInfo?.type
    const res = await this.materialTaskService.createTask({
      ...body,
      type: MediaMaterialTypeMap.get(type)!,
    })
    return res
  }

  @ApiDoc({
    summary: 'Preview Draft Generation Task',
    description: 'Preview the content generated by a draft task.',
  })
  @Get('task/preview/:id')
  async previewTask(@Param('id') id: string) {
    const res = await this.materialTaskService.previewTask(id)
    return res
  }

  @ApiDoc({
    summary: 'Start Draft Generation Task',
    description: 'Start processing the draft generation task.',
  })
  @Get('task/start/:id')
  async startTask(@Param('id') id: string) {
    const res = await this.materialTaskService.startTask(id)
    return res
  }

  @ApiDoc({
    summary: 'Delete Drafts by Filter',
    description: 'Delete drafts that match the filter conditions.',
    body: MaterialFilterDto.schema,
  })
  @Delete('filter')
  async delByFilter(
    @GetToken() token: TokenInfo,
    @Body() body: MaterialFilterDto,
  ) {
    const res = await this.materialService.delByFilter(token.id, body)
    return res
  }

  @ApiDoc({
    summary: 'Delete Drafts by IDs',
    description: 'Delete drafts by specifying an ID list.',
    body: MaterialIdsDto.schema,
  })
  @Delete('list')
  async delByIds(
    @GetToken() token: TokenInfo,
    @Body() body: MaterialIdsDto,
  ) {
    const res = await this.materialService.delByIds(token.id, body.ids)
    return res
  }

  @ApiDoc({
    summary: 'Delete Draft by ID',
    description: 'Delete a draft by its identifier.',
  })
  @Delete(':id')
  async del(
    @GetToken() token: TokenInfo,
    @Param('id') id: string,
  ) {
    const material = await this.materialService.getInfo(id)
    if (!material || material.userId !== token.id) {
      throw new AppException(ResponseCode.MaterialNotFound, 'Material not found')
    }
    const res = await this.materialService.del(id)
    return res
  }

  @ApiDoc({
    summary: 'Update Draft Information',
    description: 'Update the draft details by ID.',
    body: UpdateMaterialDto.schema,
  })
  @Put('info/:id')
  async upMaterialInfo(
    @GetToken() token: TokenInfo,
    @Param('id') id: string,
    @Body() body: UpdateMaterialDto,
  ) {
    const material = await this.materialService.getInfo(id)
    if (!material || material.userId !== token.id) {
      throw new AppException(ResponseCode.MaterialNotFound, 'Material not found')
    }
    const res = await this.materialService.updateInfo(id, body)
    return res
  }

  @ApiDoc({
    summary: 'Get Draft by ID',
    description: 'Get a draft by its identifier.',
  })
  @Get('info/:id')
  async getInfo(@Param('id') id: string) {
    const res = await this.materialService.getInfo(id)
    return res
  }

  @ApiDoc({
    summary: 'List Drafts',
    description: 'Retrieve a paginated list of drafts with optional filters.',
    query: MaterialFilterSchema,
  })
  @Get('list/:pageNo/:pageSize')
  async getList(
    @GetToken() token: TokenInfo,
    @Param() param: TableDto,
    @Query() query: MaterialFilterDto,
  ) {
    const res = await this.materialService.getList(
      param,
      {
        ...query,
        ...(!query.groupId && { userId: token.id, userType: UserType.User }),
      },
    )

    for (const item of res.list) {
      item.coverUrl = fileUtil.buildUrl(item.coverUrl)
      for (const media of item.mediaList) {
        media.url = fileUtil.buildUrl(media.url)
        media.thumbUrl = fileUtil.buildUrl(media.thumbUrl)
      }
    }
    return res
  }
}
